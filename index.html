<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<title>å®‰å…¨ä¹¦ç­¾æ ‘ (WASM + Ephemeral)</title>
<style>
body{font-family: Arial, sans-serif; padding:20px; background:#f5f6f9; color:#333;}
.container{max-width:1000px; margin:0 auto; background:#fff; padding:20px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.08);}
.toolbar{display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;}
.toolbar .right{display:flex; gap:8px; align-items:center;}
.btn{padding:6px 10px; border-radius:6px; border:none; cursor:pointer; background:#e9eef7;}
.btn-primary{background:#06f; color:#fff;}
input, select{padding:6px 8px; border:1px solid #ddd; border-radius:6px;}
.tree{list-style:none; padding-left:12px; margin:0;}
.tree li{position:relative; margin:3px 0;}
.tree li .node-header{display:flex; justify-content:space-between; align-items:center;padding:4px 6px; border-radius:6px;}
.tree li .node-header:hover{ background:#f2f6ff; }
.tree li .node-label{ display:flex; align-items:center; gap:6px; min-width:0; }
.tree li .node-label .icon{ width:1.2em; text-align:center; flex:0 0 auto; }
.tree li .name{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.tree li ul{ display:none; padding-left:18px; margin:0; }
.tree li.open > ul{ display:block; }
.node-actions{ flex:0 0 auto; display:flex; gap:6px; }
.node-actions .btn{ padding:2px 6px; }
.selected{ background:#cfe4ff !important; }
.tag{ font-size:12px; padding:2px 6px; border-radius:999px; background:#eef3ff; color:#356; margin-left:6px; }
.drag-over{ outline:2px dashed #06f; outline-offset:2px; }
:root{--bg-color:#ffffff;--text-color:#000000;}
body{background: var(--bg-color); color: var(--text-color); transition: all 0.3s ease;}
.theme-picker{margin: 1rem;}
#batchActions{margin-bottom:10px;}
</style>
</head>
<body>
<div class="container">
  <div class="toolbar">
  <h2>ğŸ”’ å®‰å…¨ä¹¦ç­¾æ ‘ (WASM + Ephemeral)</h2>

  <div class="theme-picker">
    <label>é€‰æ‹©ä¸»é¢˜é¢œè‰²: </label>
    <input type="color" id="bgPicker" value="#ffffff" />
    <input type="color" id="textPicker" value="#000000" />
  </div>

  <div class="right">
    <input id="searchInput" placeholder="æœç´¢åç§°æˆ–æ ‡ç­¾..." />

	<span style="font-size:0.85em; margin-left:8px;">LocalStorage æ•°æ®å¯¼å…¥å¯¼å‡º</span>
	<button id="exportBtn" class="btn">å¯¼å‡ºæ•°æ®</button>

	<!-- ä»…åœ¨ç¼–è¾‘æ¨¡å¼æ˜¾ç¤º -->
	<input type="file" id="importFile" style="display:none" />
	<button id="importBtn2" class="btn" style="display:none">å¯¼å…¥æ•°æ®</button>
	<button id="importBtn" class="btn" style="display:none">æ‰¹é‡å¯¼å…¥</button>

	<button id="clearSearchBtn" class="btn">æ¸…ç©ºæœç´¢</button>
	<button id="editorBtn" class="btn">è¿›å…¥ç¼–è¾‘æ¨¡å¼</button>

    <pre id="preview" style="margin-top:4px;"></pre>
  </div>
</div>


  <!-- ç¼–è¾‘æ¨¡å¼æ‰¹é‡æ“ä½œ -->
  <div id="batchActions" style="display:none;">
    <select id="batchMoveTarget">
      <option value="">æ ¹ç›®å½•</option>
    </select>
    <button id="batchMoveBtn" class="btn">æ‰¹é‡ç§»åŠ¨</button>
    <button id="batchDeleteBtn" class="btn btn-primary">æ‰¹é‡åˆ é™¤</button>
  </div>

  <div id="editorPanel" style="display:none; margin-bottom:10px;">
    <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
      <select id="typeIn">
        <option value="file">æ–‡ä»¶</option>
        <option value="folder">æ–‡ä»¶å¤¹</option>
      </select>
      <input id="titleIn" placeholder="åç§°" />
      <input id="urlIn" placeholder="URLï¼ˆä»…æ–‡ä»¶ç”¨ï¼‰" />
      <input id="tagIn" placeholder="æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰" />
      <select id="parentIn"></select>
      <button id="addBtn" class="btn btn-primary">æ·»åŠ </button>
    </div>
  </div>

  <ul class="tree" id="bookmarkTree"></ul>
</div>

<script type="module">
import init, {
  use_embedded_key, verify_editor,
  load_cipher_and_get_censored, get_censored_json,
  get_and_refresh_eph_map, open_by_eph,
  add_node, edit_node, delete_node, move_node, export_encrypted,
  init_sample_if_empty
} from '/pkg/wasm_crypto.js';

const STORAGE_KEY = "bookmarks_cipher_wasm_ephem_v1";
let isEditor=false, censored=[], ephMap={}, filterKeyword='';

// åˆå§‹åŒ–
async function boot(){
  await init(); use_embedded_key();
  
  
  
   // await loadDefaultData();
  const cipher = localStorage.getItem(STORAGE_KEY);
  if(cipher){ try{ censored=JSON.parse(await load_cipher_and_get_censored(cipher)); } catch{ init_sample_if_empty(); censored=JSON.parse(await get_censored_json()); } }
  else{ init_sample_if_empty(); censored=JSON.parse(await get_censored_json()); }
  ephMap=JSON.parse(await get_and_refresh_eph_map());
  renderTree(); bindUI(); updateParentOptions(); updateBatchMoveOptions();
}

// æ„å»ºæ ‘
function buildHierarchy(list, kw=''){
  const byId = new Map(list.map(n=>[n.id,{...n, children:[]}]));
  const roots=[];
  for(const n of byId.values()){ n.parent && byId.has(n.parent)?byId.get(n.parent).children.push(n):roots.push(n); }
  if(!kw) return roots;
  const k = kw.toLowerCase();
  function prune(n){ const selfMatch=n.title.toLowerCase().includes(k)||(n.tag && n.tag.toLowerCase().includes(k)); const kids=(n.children||[]).map(prune).filter(Boolean); return (selfMatch||kids.length)?{...n,children:kids}:null; }
  return roots.map(prune).filter(Boolean);
}

// æ¸²æŸ“æ ‘
function renderTree(){
  const tree = document.getElementById('bookmarkTree'); 
  tree.innerHTML='';
  const roots = buildHierarchy(censored, filterKeyword);
   roots.forEach(r=>tree.appendChild(renderNode(r)));
   
   
  function renderNode(n){
    const li=document.createElement('li'); 
    li.className=n.node_type;

    const header=document.createElement('div'); 
    header.className='node-header';

    // å¤šé€‰ checkbox
    if(isEditor){
      const checkbox = document.createElement('input');
      checkbox.type='checkbox';
      checkbox.className='selectNode';
      checkbox.dataset.id = n.id;
      header.appendChild(checkbox);
    }

    const label=document.createElement('div'); 
    label.className='node-label';

    const icon=document.createElement('span'); 
    icon.className='icon'; 
    icon.textContent=n.node_type==='folder'?'ğŸ“':'ğŸŒ';

    const name=document.createElement('span'); 
    name.className='name'; 
    name.textContent=n.title;

    // âœ… åªåœ¨ç‚¹å‡» name æ—¶è§¦å‘æ‰“å¼€
    if(n.node_type === 'file'){
      name.onclick = async e => {
        e.stopPropagation();
        const eph = ephMap[n.id];
        if(!eph){
          alert('ä¸´æ—¶IDè¿‡æœŸ'); 
          return;
        }
        await open_by_eph(eph);
        ephMap = JSON.parse(await get_and_refresh_eph_map());
      };
    } else if(n.node_type === 'folder'){
      name.onclick = e => {
        e.stopPropagation();
        li.classList.toggle('open');
      };
    }

    label.appendChild(icon); 
    label.appendChild(name);
    if(n.tag){ 
      const t=document.createElement('span'); 
      t.className='tag'; 
      t.textContent=n.tag; 
      label.appendChild(t);
    }
    header.appendChild(label);

    if(isEditor){
      const actions=document.createElement('div'); 
      actions.className='node-actions';

      const editBtn=document.createElement('button'); 
      editBtn.className='btn'; 
      editBtn.textContent='ç¼–è¾‘';
      editBtn.onclick=async e=>{
        e.stopPropagation(); 
        const nt=prompt('åç§°ï¼š',n.title)||n.title; 
        let nu=null; 
        if(n.node_type==='file'){ nu=prompt('URL','')||''; } 
        const tg=prompt('æ ‡ç­¾ï¼š',n.tag||'')||n.tag||''; 
        await edit_node(n.id,nt,nu,tg,n.parent||null); 
        await saveAndRefresh(); 
      };

      const moveBtn=document.createElement('button'); 
      moveBtn.className='btn'; 
      moveBtn.textContent='ç§»åŠ¨';
      moveBtn.onclick=async e=>{
        e.stopPropagation(); 
        const pid=prompt('è¾“å…¥ç›®æ ‡çˆ¶çº§IDï¼ˆç•™ç©º=æ ¹ï¼‰',n.parent||''); 
        await move_node(n.id,pid||null); 
        await saveAndRefresh(); 
      };

      const delBtn=document.createElement('button'); 
      delBtn.className='btn'; 
      delBtn.textContent='åˆ é™¤';
      delBtn.onclick=async e=>{
        e.stopPropagation(); 
        if(confirm('ç¡®å®šåˆ é™¤ï¼Ÿ')){ 
          await delete_node(n.id); 
          await saveAndRefresh(); 
        } 
      };

      actions.appendChild(editBtn); 
      actions.appendChild(moveBtn); 
      actions.appendChild(delBtn);
      header.appendChild(actions);
    }

    li.appendChild(header);

    if(n.children && n.children.length){ 
      const ul=document.createElement('ul'); 
      n.children.forEach(c=>ul.appendChild(renderNode(c))); 
      li.appendChild(ul); 
    }

    return li;
  }
     
	 
	 
	 
	 
	 
	 
	 
	 renderBatchActions();
 
}

// æ›´æ–°çˆ¶çº§ä¸‹æ‹‰
function updateParentOptions() {
  const sel = document.getElementById('parentIn'); // ç¡®ä¿ select çš„ id æ˜¯ parentIn
  if (!sel) return;

  sel.innerHTML = ''; // å…ˆæ¸…ç©º

  // æ ¹ç›®å½•é€‰é¡¹
  sel.innerHTML = `<option value="">æ ¹ç›®å½•</option>`;

  // éå† censored ä¸­æ‰€æœ‰ folderï¼Œç”Ÿæˆ option
  censored
    .filter(n => n.node_type === 'folder')
    .forEach(f => {
      sel.innerHTML += `<option value="${f.id}">${f.title} (${f.id})</option>`;
    });
}


// æ›´æ–°æ‰¹é‡ç§»åŠ¨ä¸‹æ‹‰
function updateBatchMoveOptions(){
  const sel=document.getElementById('batchMoveTarget'); sel.innerHTML='<option value="">æ ¹ç›®å½•</option>';
  censored.filter(n=>n.node_type==='folder').forEach(f=>{ sel.innerHTML+=`<option value="${f.id}">${f.title}</option>`; });
}

// ä¿å­˜åˆ·æ–°
async function saveAndRefresh(){
  const b64=await export_encrypted(); localStorage.setItem(STORAGE_KEY,b64);
  censored=JSON.parse(await get_censored_json()); ephMap=JSON.parse(await get_and_refresh_eph_map());
  renderTree(); updateParentOptions(); updateBatchMoveOptions();
}

// UIç»‘å®š
function bindUI(){
  const editorBtn=document.getElementById('editorBtn'); const editorPanel=document.getElementById('editorPanel'); const batchActions=document.getElementById('batchActions');
  editorBtn.onclick=async ()=>{
    if(!isEditor){
      const pass=prompt('è¯·è¾“å…¥ç¼–è¾‘å£ä»¤'); if(!pass) return;
      if(!verify_editor(pass)){ alert('å£ä»¤é”™è¯¯'); return; }
      isEditor=true; editorPanel.style.display='block'; batchActions.style.display='block'; editorBtn.textContent='é€€å‡ºç¼–è¾‘æ¨¡å¼';
	  // åˆ‡æ¢ç¼–è¾‘æ¨¡å¼
  
  document.getElementById('importFile').style.display = isEditor ? 'inline-block' : 'none';
  document.getElementById('importBtn2').style.display = isEditor ? 'inline-block' : 'none';
  document.getElementById('importBtn').style.display = isEditor ? 'inline-block' : 'none';
  renderTree(); // åˆ·æ–°ä¹¦ç­¾æ ‘æ˜¾ç¤ºå¤šé€‰ checkbox
 
      renderTree();
    } else {
      isEditor=false; editorPanel.style.display='none'; batchActions.style.display='none'; editorBtn.textContent='è¿›å…¥ç¼–è¾‘æ¨¡å¼'; renderTree();
    }
  };

  document.getElementById('addBtn').onclick=async ()=>{
    if(!isEditor){ alert('è¯·å…ˆè¿›å…¥ç¼–è¾‘æ¨¡å¼'); return; }
    const tp=document.getElementById('typeIn').value; const t=document.getElementById('titleIn').value.trim();
    const u=document.getElementById('urlIn').value.trim(); const tg=document.getElementById('tagIn').value.trim();
    const p=document.getElementById('parentIn').value||null; if(!t){ alert('åç§°å¿…å¡«'); return; }
    await add_node(JSON.stringify({id:'', node_type:tp, title:t, url:tp==='file'?u:null, tag:tg||null, parent:p})); await saveAndRefresh();
    document.getElementById('titleIn').value=''; document.getElementById('urlIn').value=''; document.getElementById('tagIn').value=''; document.getElementById('typeIn').value='file'; document.getElementById('parentIn').value='';
  };

  document.getElementById('searchInput').oninput=e=>{ filterKeyword=e.target.value.trim(); renderTree(); };

 
  
  
   document.getElementById('importBtn').onclick = async () => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';

  input.onchange = async e => {
    const file = e.target.files[0];
    if (!file) return;

    const text = await file.text();
    let list = [];
    try {
      list = JSON.parse(text);
    } catch {
      return alert('âŒ JSON æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶å†…å®¹');
    }

    let successCount = 0;
    for (const it of list) {
      if (!it.title) continue;
      await add_node(JSON.stringify({
        id: '',
        node_type: it.node_type || 'file',
        title: it.title,
        url: it.url || null,
        tag: it.tag || null,
        parent: it.parent || null
      }));
      successCount++;
    }

    // æ•°æ®ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
    const b64 = await export_encrypted();
    localStorage.setItem(STORAGE_KEY, b64);

    censored = JSON.parse(await get_censored_json());
    ephMap = JSON.parse(await get_and_refresh_eph_map());

    renderTree();
    updateParentOptions();

    // âœ… å¯¼å…¥æˆåŠŸæç¤º
    alert(`âœ… å¯¼å…¥æˆåŠŸï¼Œå…±å¯¼å…¥ ${successCount} æ¡æ•°æ®`);
  };

  input.click();
};

 
}

// ä¸»é¢˜
function applyTheme(theme){ document.documentElement.style.setProperty("--bg-color",theme.bg); document.documentElement.style.setProperty("--text-color",theme.text); }
const savedTheme=JSON.parse(localStorage.getItem("userTheme")); if(savedTheme) applyTheme(savedTheme);
document.getElementById("bgPicker").oninput=e=>{ const theme={bg:e.target.value, text:document.getElementById("textPicker").value}; applyTheme(theme); localStorage.setItem("userTheme",JSON.stringify(theme)); };
document.getElementById("textPicker").oninput=e=>{ const theme={bg:document.getElementById("bgPicker").value, text:e.target.value}; applyTheme(theme); localStorage.setItem("userTheme",JSON.stringify(theme)); };





// âœ… å¯¼å‡º LocalStorage æ•°æ®ä¸º JSON æ–‡ä»¶
    document.getElementById("exportBtn").onclick = function () {
      const data = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        data[key] = localStorage.getItem(key);
      }
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "localStorage-data.json";
      a.click();

      URL.revokeObjectURL(url);
    };
	
	
	// âœ… å¯¼å…¥ JSON æ–‡ä»¶å†™å…¥ LocalStorage
  document.getElementById("importBtn2").onclick = async function () {
  const fileInput = document.getElementById("importFile");
  if (!fileInput.files.length) {
    alert("è¯·é€‰æ‹©ä¸€ä¸ª JSON æ–‡ä»¶ï¼");
    return;
  }

  const file = fileInput.files[0];
  const reader = new FileReader();

  reader.onload = async function (e) {
    try {
      const data = JSON.parse(e.target.result);

      // éå† JSON çš„æ¯ä¸ª keyï¼Œå†™å…¥ localStorage
      for (const key in data) {
        localStorage.setItem(key, data[key]);
      }

      // ç«‹å³åˆ·æ–°ä¹¦ç­¾æ ‘
      if (localStorage.getItem(STORAGE_KEY)) {
        try {
          censored = JSON.parse(await load_cipher_and_get_censored(localStorage.getItem(STORAGE_KEY)));
        } catch (err) {
          alert("è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ–‡ä»¶ä¸æ˜¯æ­£ç¡®çš„ Base64 åŠ å¯†æ ¼å¼");
          return;
        }
      }

      // åˆ·æ–° ephMap
      ephMap = JSON.parse(await get_and_refresh_eph_map());

      // æ¸²æŸ“ä¹¦ç­¾æ ‘
      renderTree();
      updateParentOptions();

      alert("å¯¼å…¥æˆåŠŸï¼Œä¹¦ç­¾æ ‘å·²åˆ·æ–°ï¼");
    } catch (err) {
      alert("å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼é”™è¯¯ï¼");
      console.error(err);
    }
  };

  reader.readAsText(file);
};

async function loadDefaultDataFromFile(filename = './localStorage-data22.json') {
  try {
    // è¯»å–æœ¬åœ°åŠ å¯† JSON æ–‡ä»¶
    const res = await fetch(filename);
    const fileContent = await res.text();

    // è§£æ JSON
    const localData = JSON.parse(fileContent);

    // å–å‡ºåŠ å¯†æ•°æ®
    const cipher = localData["bookmarks_cipher_wasm_ephem_v1"];
    if (!cipher) throw new Error("JSON ä¸­æœªæ‰¾åˆ°åŠ å¯†å­—æ®µ bookmarks_cipher_wasm_ephem_v1");

    // ä¿å­˜åˆ° localStorage (å¯é€‰)
    localStorage.setItem(STORAGE_KEY, cipher);

    // ä½¿ç”¨ wasm å‡½æ•°è§£å¯†
    censored = JSON.parse(await load_cipher_and_get_censored(cipher));

    // åˆ·æ–°ä¸´æ—¶ ephMap
    ephMap = JSON.parse(await get_and_refresh_eph_map());

    // æ¸²æŸ“ä¹¦ç­¾æ ‘å’Œçˆ¶çº§ä¸‹æ‹‰
    renderTree();
    updateParentOptions();

    console.log("é»˜è®¤æ•°æ®åŠ è½½å®Œæˆï¼");
  } catch (err) {
    console.error("åŠ è½½é»˜è®¤æ•°æ®å¤±è´¥ï¼š", err);
    alert("åŠ è½½é»˜è®¤ä¹¦ç­¾æ•°æ®å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æˆ–è·¯å¾„ï¼");
  }
}





 
 
 
 
 
 
 
  


   
 
 
 
function renderBatchActions() {  
 if (!isEditor) return;

function tryInsert() {
  const tree = document.getElementById("bookmarkTree");
  if (!tree || !tree.parentNode) {
    requestAnimationFrame(tryInsert);
    return;
  }

  let panel = document.getElementById("batchPanel");
  if (!panel) {
    panel = document.createElement("div");
    panel.id = "batchPanel";
    panel.className = "batch-panel";

    // æ‰¹é‡ç§»åŠ¨ä¸‹æ‹‰é€‰æ‹©
    panel.appendChild(document.createTextNode("ç§»åŠ¨åˆ°ï¼š "));
    const folderSelect = document.createElement("select");
    folderSelect.id = "batchTargetFolder";
    panel.appendChild(folderSelect);

    // æ‰¹é‡ç§»åŠ¨æŒ‰é’®
    const batchMoveBtn = document.createElement("button");
    batchMoveBtn.textContent = "æ‰§è¡Œç§»åŠ¨";
    batchMoveBtn.onclick = async () => {
      const nodes = document.querySelectorAll(".selectNode:checked");
      if (nodes.length === 0) { alert("è¯·å…ˆé€‰æ‹©èŠ‚ç‚¹"); return; }
      const pid = folderSelect.value || null;
      for (let chk of nodes) {
        const id = chk.dataset.id;
        await move_node(id, pid);
      }
      await saveAndRefresh();
    };
    panel.appendChild(batchMoveBtn);

    // æ‰¹é‡æ”¹æ ‡ç­¾
    const batchTagBtn = document.createElement("button");
    batchTagBtn.textContent = "æ‰¹é‡æ”¹æ ‡ç­¾";
    batchTagBtn.onclick = async () => {
      const nodes = document.querySelectorAll(".selectNode:checked");
      if (nodes.length === 0) { alert("è¯·å…ˆé€‰æ‹©èŠ‚ç‚¹"); return; }
      const newTag = prompt("è¾“å…¥æ–°çš„æ ‡ç­¾ï¼š", "");
      if (newTag === null) return;
      for (let chk of nodes) {
        const id = chk.dataset.id;
        await edit_node(id, null, null, newTag, null);
      }
      await saveAndRefresh();
    };
    panel.appendChild(batchTagBtn);

    // æ‰¹é‡åˆ é™¤
    const batchDelBtn = document.createElement("button");
    batchDelBtn.textContent = "æ‰¹é‡åˆ é™¤";
    batchDelBtn.onclick = async () => {
      const nodes = document.querySelectorAll(".selectNode:checked");
      if (nodes.length === 0) { alert("è¯·å…ˆé€‰æ‹©èŠ‚ç‚¹"); return; }
      if (!confirm("ç¡®å®šè¦æ‰¹é‡åˆ é™¤è¿™äº›èŠ‚ç‚¹å—ï¼Ÿ")) return;
      for (let chk of nodes) {
        const id = chk.dataset.id;
        await delete_node(id);
      }
      await saveAndRefresh();
    };
    panel.appendChild(batchDelBtn);
  }

  // ğŸ”¹ æ¯æ¬¡æ¸²æŸ“å‰åˆ·æ–°ä¸‹æ‹‰åˆ—è¡¨
  const folderSelect = document.getElementById("batchTargetFolder");
  if (folderSelect) {
    folderSelect.innerHTML = '';
    const rootOption = document.createElement("option");
    rootOption.value = '';
    rootOption.textContent = "æ ¹ç›®å½•";
    folderSelect.appendChild(rootOption);
    censored.filter(n => n.node_type === 'folder')
            .forEach(f => {
              const opt = document.createElement("option");
              opt.value = f.id;
              opt.textContent = f.title;
              folderSelect.appendChild(opt);
            });
  }

  if (!tree.parentNode.contains(panel)) {
    tree.parentNode.insertBefore(panel, tree);
  }
}

requestAnimationFrame(tryInsert);

}



 
 
boot();
bindUI(); 
loadDefaultDataFromFile();

    


</script>
</body>
</html>
